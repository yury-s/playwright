#!/usr/bin/env node
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const fs = require('fs');
const path = require('path');
const yaml = require('yaml');

const channels = new Set();

function titleCase(name) {
  return name[0].toUpperCase() + name.substring(1);
}

function innerType(propertyName, type, indent) {
  if (typeof type === 'string') {
    const optional = type.endsWith('?');
    if (optional)
      type = type.substring(0, type.length - 1);
    switch(type) {
      case 'binary': return { name: 'Binary', definition: '' };
      case 'json': return { name: 'JsonObject', definition: '' };
      case 'string': return { name: 'String', definition: '' };
      case 'boolean': return { name: optional ? 'Boolean' : 'boolean', definition: '' };
      case 'number': return { name: 'Number', definition: '' };
      default:
        break;
    }
    if (channels.has(type))
      return { name: `${type}Channel`, definition: '' };
    if (type === 'Channel')
      return { name: `Channel`, definition: '' };
    return { name: type, definition: '' };
  }
  if (type.type.startsWith('array')) {
    const inner = innerType(propertyName, type.items, indent, true);
    return { name: `${inner.name}[]`, definition: `${inner.definition}` };
  }
  if (type.type.startsWith('enum')) {
    const values = type.literals.map(literal => `'${literal}`).join(', ');
    return { name: 'String', definition: `// Possible values: { ${values} }` };
  }
  if (type.type.startsWith('object')) {
    const inner = properties(type.properties, indent + '  ');
    const name = `${titleCase(propertyName)}`;
    return { name, definition: `public static class ${name} {\n${inner}\n${indent}}`};
  }
  throw new Error('Invalid type: ' + JSON.stringify(type, null, 2));
}

function properties(props, indent) {
  const ts = [];
  for (const [name, value] of Object.entries(props)) {
    const inner = innerType(name, value, indent);
    if (inner.definition)
      ts.push(`${indent}${inner.definition}`);
    ts.push(`${indent}${inner.name} ${name};`);
  }
  return ts.join('\n');
}

function objectType(props, indent) {
  if (!Object.entries(props).length)
    return '';
  return properties(props, indent + '  ');
}

const channels_ts = [
`/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// This file is generated by ${path.basename(__filename)}, do not edit manually.

package com.microsoft.playwright;

class Binary {
}

class Channel {
}
`];

const yml = fs.readFileSync(path.join(__dirname, '..', 'src', 'protocol', 'protocol.yml'), 'utf-8');
const protocol = yaml.parse(yml);

const inherits = new Map();
for (const [name, value] of Object.entries(protocol)) {
  if (value.type === 'interface') {
    channels.add(name);
    if (value.extends)
      inherits.set(name, value.extends);
  }
}

for (const [name, item] of Object.entries(protocol)) {
  if (item.type === 'interface') {
    continue;

    const channelName = name;
    channels_ts.push(`// ----------- ${channelName} -----------`);
    const init = objectType(item.initializer || {}, '');
    const initializerName = channelName + 'Initializer';
    channels_ts.push(`export type ${initializerName} = ${init.ts};`);

    channels_ts.push(`export interface ${channelName}Channel extends ${(item.extends || '') + 'Channel'} {`);
    const ts_types = new Map();

    for (let [eventName, event] of Object.entries(item.events || {})) {
      if (event === null)
        event = {};
      const parameters = objectType(event.parameters || {}, '');
      const paramsName = `${channelName}${titleCase(eventName)}Event`;
      ts_types.set(paramsName, parameters.ts);
      channels_ts.push(`  on(event: '${eventName}', callback: (params: ${paramsName}) => void): this;`);
    }

    for (let [methodName, method] of Object.entries(item.commands || {})) {
      if (method === null)
        method = {};
      const parameters = objectType(method.parameters || {}, '');
      const paramsName = `${channelName}${titleCase(methodName)}Params`;
      const optionsName = `${channelName}${titleCase(methodName)}Options`;
      ts_types.set(paramsName, parameters.ts);
      ts_types.set(optionsName, objectType(method.parameters || {}, '', true).ts);

      const resultName = `${channelName}${titleCase(methodName)}Result`;
      const returns = objectType(method.returns || {}, '');
      ts_types.set(resultName, method.returns ? returns.ts : 'void');

      channels_ts.push(`  ${methodName}(params${method.parameters ? '' : '?'}: ${paramsName}, metadata?: Metadata): Promise<${resultName}>;`);
    }

    channels_ts.push(`}`);
    for (const [typeName, typeValue] of ts_types)
      channels_ts.push(`export type ${typeName} = ${typeValue};`);
  } else if (item.type === 'object') {
    const inner = objectType(item.properties, '');
    channels_ts.push(`class ${name}{\n${inner}\n}\n`);
  }
  channels_ts.push(``);
}

let hasChanges = false;

function writeFile(filePath, content) {
  const existing = fs.readFileSync(filePath, 'utf8');
  if (existing === content)
    return;
  hasChanges = true;
  const root = path.join(__dirname, '..');
  console.log(`Writing //${path.relative(root, filePath)}`);
  fs.writeFileSync(filePath, content, 'utf8');
}

writeFile(path.join(__dirname, '../java/src/main/java/com/microsoft/playwright/Protocol.java'), channels_ts.join('\n'));
process.exit(hasChanges ? 1 : 0);
